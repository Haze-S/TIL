## 리스트의 개념

- 어떤 정의에 의해서 결정된 **논리적인 순서**
- 리스트의 *순서는* 데이터가 저장되는 물리적인 위치와 상관없이 사람들 머릿속에 인식되는 **논리적인 순서** 혹은 원소값들의 **의미적인 순서**를 의미한다.
- 배열의 경우 **인덱스로 표현되는 순서**가 배열 원소의 메모리공간에서의 **물리적인 위치**라면 리스트의 **순서**개념은 어떤 정의에 의해서 결정된 **논리적인 순서**이다.

## 배열을 이용한 리스트의 구현

### 리스트의 구현

- 원소값을 간단하게 1차원 배열에 순서대로 저장한다.
- 상대적으로 간단하며 포인터를 위한 메모리가 필요 없어서 메모리의 공간 활용 효율이 높다.
- 원소값의 삽입이나 삭제에 많은 시간이 걸린다.

### 원소 삽입과 삭제

- 만약 리스트의 중간에 원소값을 삽입해야 한다면
    1. 배열의 처음 크기는 확장되어야 한다.
    2. 삽입되는 원소 값의 뒤의 값들은 한 칸씩 뒤로 밀려나야 한다.
- 배열로 구현된 리스트는 원소의 주소가 **연속적인** 물리적 주소에 저장된다.
- 삭제가 될 경우도 마찬가지로 삭제 후 해당 노드의 뒤의 값들을 한칸씩 당겨야한다.

### 배열의 확장

- 초기 선언에서 충분히 크게하면 추가 확장을 피할 순 있지만 메모리 낭비가 일어나고, 모자랄 경우 프로그램 코드 자체의 변화가 발생한다. 또한 어차피 삽입, 삭제 시엔 원소 값들의 이동이 발생한다.
- 원소 값의 이동은 수가 많을 수록 프로그램 수행 시간을 증가시키고 삽입은 프로그램의 실행 중에 메모리 할당을 필요로 하기도 한다.
- 자료의 삽입과 삭제가 빈번히 발생하는 상황에서 리스트를 배열로 구현하는 것은 빈번한 자료이동으로 인한 비효율적인 컴퓨팅 성능을 유발한다.

## 포인터를 이용한 리스트의 구현

### 노드 (node)

- **리스트의 원소값** + **다음 원소를 가리키는 정보**(포인터, 주소, 링크)
- 노드는 데이터요소(원소, 값)와 리스트의 다음 원소가 저장될 위치의 주소값을 저장한다.

### 특징

- 리스트의 원소값들이 메모리에 연속적으로 저장될 필요가 없이 드문드문 저장되어도 된다.
- 구체적인 값은 시스템에 의해 제공되므로 추상화된 리스트의 모습만 생각하면 된다.
- 링크 부분에 해당하는 연결고리만 상상하며 프로그램을 작성한다.

### 연결 리스트

- 노드간의 포인터 연결을 통해 구현되는 리스트
- 노드는 최소 두 종류의 필드가 있어야 하며, 원소값을 저장하는 데이터 필드와 노드 연결을 위한 링크 필드를 가진다.
- 데이터 필드는 필요에 따라 여러 필드로 이루어져 있다.
- 마지막 노드의 링크는 더이상 가리킬 것이 없는 null pointer로 표현된다.

## 포인터 변수

- C에서 포인터는 주소값을 저장하기 위한 자료구조를 제공한다.
- 포인터는 메모리의 주소값을 저장하는 변수로서 일반 변수와 마찬가지로 저장할 수 있는 변수 주소값에 대한 데이터 타입을 가진다.
- 포인터 변수의 선언은 변수 이름과 자료형 사이에 `*`를 붙이면 된다.
- 포인터 변수에 주소값을 할당하는 방법은 `b=&a;`이며, `&`는 새롭게 나타난 **단항연산자**이다.
    - 역 참조 연산자라고도 하며 `&a`의 형태를 가진다.
    - 변수 a의 메모리 주소를 결과값으로 돌려준다.

```c
int a;   // 변수
int *p_a // 포인터
p_a = &a; // p_a에 변수 a의 주소를 저장
a = 231;
*p_a = 521; 
// p_a가 지시하고 있는 주소(실제로는 a의 주소)를 찾아가서 521을 저장(a = 521;과 동일)
```

### 구조체 포인터 타입

- 다양한 데이터 형의 변수를 하나의 상자에 넣어 선언, 혹은 사용하는 C문법이 구조체(struct)
- 다양한 데이터 형을 하나의 단위로 자를 수 있어서 객체에 대한 정보를 모아서 사용할 때 유용하다.
- 리스트의 생성
    - 정수값 data와 링크 link로 구성된 노드의 생성

```c
struct linked_list_node {
	int data;
	struct linked_list_node*link;
};
```

### 프로그램 실행 중 구조체 메모리 할당

- 배열을 이용한 리스트의 구현과는 확장성에서 차이가 있을 수 있다.
- 배열의 경우 그 크기와 원소의 수가 차이가 날 경우 문제를 발생시킨다.
- 이러한 단점을 보완하기 위해 동적으로 메모리 공간을 할당받아 리스트 원소를 새롭게 할당받은 메모리 공간에 저장하고 새롭게 할당받은 메모리 공간을 연결할 수 있는 구현 방법이 C에서 제공이 된다.

## 연산 프로그램

### 생성

- 연결 리스트에서 원소는 연결될 다음 원소에 대한 주소를 저장해야 한다.
- 노드 : <데이터, 주소>의 쌍으로 구성된다.
- 단일 연결 리스트의 생성

```c
// 단순 연결 리스트의 노드 구조 정의
typedef struct ListNode {
	int data[10];
	struct ListNode* link;
} listNode;

//리스트의 헤드(first) 노드 구조 정의
typedef struct {
	listNode* head;
} linkedList_h;

// 연결 리스트 생성
linkedList_h* createLinkedList_h(void) {
	linkedList* H;
	H = (linkedList_h*)malloc(sizeof(linkedList_h));
	H -> head = Null;
	return H;
}
```

### 노드 삽입

- 리스트의 원소 삽입 연산 단계
- **순서가 중요하다**
    1. 메모리 공간을 할당받고 삽입할 내용을 저장하여 삽입할 노드x를 생성한다.
    2. 노드x의 링크 부분이 후행 노드가 될 노드j를 가리키게 한다.
    3. 삽입될 노드x의 선행 노드가 될 노드 i의 링크 필드가 x를 가리키게 한다.

### 노드 삭제

- 리스트의 원소 삭제 연산 단계
    - **삭제할 노드의 선행 노드의 링크 필드를 삭제할 노드의 후행 노드를 가리키게 한다**
    - 삭제할 노드를 메모리에 반환한다.