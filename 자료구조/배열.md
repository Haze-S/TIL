# 배열

## 1. 배열의 정의

-   차례(순서)와 관련된 기본적인 자료구조
-   개발자의 머릿속에 추상화 될 데이터가 실제로 컴퓨터엔 연속된 메로리가 저장된다.
-   **배열의 순서** = 메모리 공간에서 저장되는 **원소값의 물리적 순서**
-   인덱스와 원소값이 쌍으로 구성된 집합

### 특징

1. 원소들이 모두 값은 자료형
2. 동질의 값과 기억공간의 크기가 같다.
3. 원소의 물리적 위치 순서가 배열의 인덱스 순서와 일치한다.
4. 인덱스 값을 이용, 배열의 원소 값에 접근하는 직접 접근<br/>

※ 인덱스 값은 추상화 된 값이며 메모리 주소 값은 실제 반도체의 물리적인 위치값이다.
※ 운영체제가 실제 주소값(16진수)과 인덱스 값을 연결시켜 준다.

## 2. 배열의 추상자료형

ADT Array 객체 : &#60; i ∈ Index, e ∈ Element &#62; 쌍들의 집합.

-   index : 순서를 나타내는 원소의 유한 집합
-   Element : 타입이 같은 원소의 집합<br/>

연산 : a ∈ Array; i ∈ index; item ∈ Element; n ∈ Integer인 모든 a, item, n에 대하여 다음과 같은 연산이 정의된다.<br/>
→ a : 0개 이상의 원소를 갖는 배열<br/>
→ item : 배열에 저장되는 원소<br/>
→ n : 배열의 최대 크기를 정의하는 정수 값

① Array Create(n) ::= 배열의 크기가 n인 빈 배열을 생성하고 배열을 반환한다; <br/>
② Element retrieve(a, i) ::= <br/>if (i∈Index) <br/>then {배열의 i번째에 해당하는 원소값 'e'를 반환한다;} <br/>else{에러 메세지를 반환한다;}<br/>③ Array store(a, i, e) ::= <br/>if(i∈Index)<br/>then{배열 a의 i번째 위치에 원소값 'e'를 저장하고 a를 반환한다;}<br/>else{인덱스 i가 배열 a의 크기를 벗어나면 에러메세지를 반환한다;}

## 3. 배열의 연산의 구현

1. 공백 배열을 생성(create)

```c
void create(int n){ //n=5
    int a[n];
    int i;
    for(i=0, i<n, i++){
        a[i] = 0;
    }
}
```

2. i번째 인덱스에 저장된 원소값을 반환(retrieve)

```c
#define array_size 5
int retrieve(int *a, int i){ //i=2
    if(i >= 0 && i < array_size ) return a[i];
    else {
        printf("Error\n");
        return(-1);
    }
}
```

3. 배열에서 원하는 위치 i번째 인덱스에 원소값 e를 저장하는 연산(store)

```c
#define array_size 5
void store(int *a, int i, int e){
    if(i >= 0 && i < array_size)
        a[i] = e;
    else printf("Error\n");
}
```

## 4. 1차원 배열

-   한 줄 짜리 배열을 의미, 인덱스도 하나이다.
-   메모리 영역도 한 줄로 할당받는다.
-   A[i]는 배열의 첫번째 원소 **A[0]이 저장된 주소(a)로 부터 시작**하며 자료형의 크기(k)를 알면 간단한 계산으로 A[i]의 주소를 알 수 있다.
-   A[0]부터 A[i-1]개까지 i개의 배열 A[]를 지나서 저장된다.
-   A[]의 크기를 k라고 가정하면 A[i]의 저장 주소는 **a + i \* k** 가 된다.
-   저장소의 주소는 달라져도 **간격은 늘 같다**

## 5. 배열의 확장

### a. 행렬의 배열 표현<br/>

→ 행렬을 컴퓨터에서 표현하기에는 **2차원 배열이 적합**하다

### b. 2차원 배열

→ 1차원 배열의 확장<br/>
→ 1차원 배열을 여러개 쌓거나 세워놓은 모습이다.<br/>
→ 바둑판 모양으로 2차원 배열에서 하나의 원소는 두개의 첨자, i와 j의 쌍으로 구분<br/>
→ 두개 이상의 첨자가 필요한 배열을 다차원배열이라고 한다.<br/>
→ 첨자 i를 행(row), j를 열(column)이라 하면 A[i][j]가 위치이다.<br/>
→ 하지만 결국엔 컴퓨터 메모리에 1차원 배열로 저장되기 때문에 저장(할당)방식을 정해야 한다.<br/>
**※ 물리적 순서와 추상적인 순서가 일치한다는 성질이 지켜짐**

### c. 행우선 저장

→ 가로로 모아 놓은 1차원 배열의 저장 방식<br/>
→ 하나의 행을 연속적으로 저장(할당)한 뒤 다음 행을 저장한다.

### d. 열 우선 저장

→ 세로로 모아 놓은 1차원 배열의 저장 방식<br/>
→ 하나의 열을 연속적으로 저장(할당)한 뒤 다음 열을 저장한다.
<br/>

**※ 자료구조를 모르면 데이터 접근 순서를 모르고, 불러오는 순서가 틀리면 하드디스크의 저장 순서를 바꾸는 현상이 있어서 i/o가 늦어진다.** <br/>
※ 다차원 배열의 우선 저장 방식은 프로그래밍 언어에 따라 결정된다.<br/>
**→ 자신이 쓰는 언어가 어떤 저장 방식인지 알고 사용해야 한다.**

## 6. 희소행렬의 개념

-   희소행렬<br/>- 원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많다.<br/>- 0의 값을 저장하기 위해 불필요한 메모리가 낭비된다.<br/>- **이를 방지하기 위해 배열 전 추상화를 한번 더 해서 낭비를 막는다**<br/>

→ 0이 아닌 각 원소를 행번호, 열번호, 원소값 형태로 나타내서 첫 줄은 갯수를 표현, 그 아래로 행, 열의 좌표와 그의 원소값을 차례대로 배열로 표현한다.
